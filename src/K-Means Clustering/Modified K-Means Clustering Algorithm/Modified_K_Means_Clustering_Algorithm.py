# -*- coding: utf-8 -*-
"""Modified_K-Means_Clustering_Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B4U0-WUFRfTmrcs8cREZZAKBV_F3QWHG
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from scipy.spatial import ConvexHull
from shapely.geometry import Polygon, MultiPoint
from shapely.geometry.polygon import orient
from shapely.ops import unary_union
from google.colab import files
import time

uploaded = files.upload()
data = pd.read_csv('data.csv')

np.random.seed(42)
fig, ax = plt.subplots(figsize=(8, 8))
ax.scatter(data['x'], data['y'], s=5)
ax.set_title('Distribution of Population')
ax.set_xlabel('X Distance')
ax.set_ylabel('Y Distance')

total_data_points = len(data)
print(f"Total number of users: {total_data_points}")
plt.show()

def find_optimal_clusters(data, max_points_per_cluster):
    start_time = time.time()
    n_clusters = max(1, int(np.ceil(total_data_points / max_points_per_cluster)))
    while True:
        kmeans = KMeans(n_clusters=n_clusters,random_state=42)
        y_kmeans = kmeans.fit_predict(data[['x', 'y']])
        cluster_counts = np.bincount(y_kmeans)
        if np.all(cluster_counts <= max_points_per_cluster):
            break
        n_clusters += 1
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Time taken for clustering: {elapsed_time:.2f} seconds")
    return n_clusters, y_kmeans, kmeans, elapsed_time

max_points_per_cluster = 100
optimal_clusters, y_kmeans, kmeans, elapsed_time = find_optimal_clusters(data, max_points_per_cluster)
print(f"Optimal number of clusters: {optimal_clusters}")

def buffered_hull(points, buffer_distance=0.05):
    if len(points) < 3:
        return Polygon(points).buffer(buffer_distance)
    hull = ConvexHull(points)
    poly_points = points[hull.vertices]
    polygon = Polygon(poly_points)
    return polygon.buffer(buffer_distance)

fig, ax = plt.subplots(figsize=(8, 8))

for cluster_label in range(optimal_clusters):
    cluster_data = data[y_kmeans == cluster_label]
    ax.scatter(cluster_data['x'], cluster_data['y'], label=f'Cluster {cluster_label}', s=5)

    if len(cluster_data) > 2:
        points = np.array(cluster_data[['x', 'y']])
        hull_polygon = buffered_hull(points)
        if hull_polygon.is_valid:
            x, y = hull_polygon.exterior.xy
            ax.plot(x, y, 'k-', linewidth=0.3)

centers = kmeans.cluster_centers_
ax.scatter(centers[:, 0], centers[:, 1], c='black', s=100, alpha=1, marker='x', label='Centroids')
ax.set_title('Modified K-Means Clustering Algorithm ')
ax.set_xlabel('X Distance')
ax.set_ylabel('Y Distance')
ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1), fontsize='small', ncol=5)
fig.tight_layout()
plt.show()

cluster_counts = np.bincount(y_kmeans)

print("\n\033[1mDATA POINTS PER CLUSTER:\033[0m")
cluster_lines = [f"Cluster {cluster_label}: {count} data points" for cluster_label, count in enumerate(cluster_counts)]
max_lines = 6
formatted_output = [""] * max_lines
for i, line in enumerate(cluster_lines):
    column_index = i // max_lines
    row_index = i % max_lines
    formatted_output[row_index] += f"\033[1m{line:<30}\033[0m"
for line in formatted_output:
    print(line)

print("\n\033[1mCENTROID OF THE CLUSTERS:\033[0m")
centroids = kmeans.cluster_centers_
centroid_lines = [f"Cluster {label}: [{centroids[label][0]:.6f}, {centroids[label][1]:.6f}]" for label in range(len(centroids))]
formatted_output = [""] * max_lines
for i, line in enumerate(centroid_lines):
    column_index = i // max_lines
    row_index = i % max_lines
    formatted_output[row_index] += f"\033[1m{line:<40}\033[0m"
for line in formatted_output:
    print(line)

