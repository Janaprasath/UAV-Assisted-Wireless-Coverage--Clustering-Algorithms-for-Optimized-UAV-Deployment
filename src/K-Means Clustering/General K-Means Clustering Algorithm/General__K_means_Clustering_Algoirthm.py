# -*- coding: utf-8 -*-
"""General _K-Means_clustering_algoirthm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HTp264VyduQ7Z-Nes5oe3S5ump9S_KvB
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from scipy.spatial import ConvexHull
from shapely.geometry import Polygon
from google.colab import files
import time
from matplotlib.lines import Line2D

uploaded = files.upload()
data = pd.read_csv('data.csv')

np.random.seed(42)

plt.figure(figsize=(8, 8))
plt.scatter(data['x'], data['y'], s=5)
plt.title('Distribution of Population')
plt.xlabel('X Distance')
plt.ylabel('Y Distance')
plt.show()

total_data_points = len(data)
print(f"Total data points: {total_data_points}")

optimal_k = 11
start_time = time.time()
kmeans = KMeans(n_clusters=optimal_k, random_state=42)
kmeans.fit(data)
end_time = time.time()
time_taken = end_time - start_time
print(f"Time taken for clustering: {time_taken:.4f} seconds")

centroids = kmeans.cluster_centers_
labels = kmeans.labels_
unique_labels = set(labels)

def buffered_hull(points, buffer_distance=0.05):
    if len(points) < 3:
        return Polygon(points).buffer(buffer_distance)
    hull = ConvexHull(points)
    poly_points = points[hull.vertices]
    polygon = Polygon(poly_points)
    return polygon.buffer(buffer_distance)

colors = plt.cm.viridis(np.linspace(0, 1, len(unique_labels)))
plt.figure(figsize=(8, 8))
legend_elements = []

for k, col in zip(unique_labels, colors):
    class_member_mask = (labels == k)
    xy = data.values[class_member_mask]
    legend_elements.append(Line2D([0], [0], marker='o', color='w', markerfacecolor=col, markersize=10, label=f'Cluster {k}'))

    # Plot the convex hull for each cluster
    if len(xy) > 2:
        hull_polygon = buffered_hull(xy)
        if hull_polygon.is_valid:
            x, y = hull_polygon.exterior.xy
            plt.plot(x, y, 'k-', linewidth=0.3)  # Use thin solid lines

    plt.plot(xy[:, 0], xy[:, 1], '.', markerfacecolor=tuple(col), markersize=7, markeredgewidth=0)

for label, centroid in enumerate(centroids):
    plt.scatter(centroid[0], centroid[1], c='black', s=100, marker='x', edgecolors='w', zorder=5)

# Add a single legend entry for centroids
legend_elements.append(Line2D([0], [0], marker='X', color='w', markerfacecolor='black', markersize=10, label='Centroid'))

# Finalize the plot
plt.legend(handles=legend_elements, loc='upper center', bbox_to_anchor=(0.5, -0.1), fontsize='small', ncol=6)
plt.title('General K-Means Clustering Algorithm')
plt.xlabel('X Distance')
plt.ylabel('Y Distance')
plt.tight_layout()
plt.show()

max_lines = 4
print_data = [f"Cluster {label}: {sum(labels == label)} data points" for label in unique_labels if label != -1]
formatted_output = [""] * max_lines
for i, line in enumerate(print_data):
    column_index = i // max_lines
    row_index = i % max_lines
    formatted_output[row_index] += f"\033[1m{line:<30}\033[0m"

print("\n\033[1mDATA POINTS PER CLUSTER:\033[0m")
for line in formatted_output:
    print(line)

print_data = [f"Cluster {label}: {centroid}" for label, centroid in enumerate(centroids)]
formatted_output = [""] * max_lines
for i, line in enumerate(print_data):
    column_index = i // max_lines
    row_index = i % max_lines
    formatted_output[row_index] +=  f"\033[1m{line:<45}\033[0m"
print("\n\033[1mCENTROID OF THE CLUSTERS:\033[0m")
for line in formatted_output:
    print(line)

